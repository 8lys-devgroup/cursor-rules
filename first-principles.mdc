---
description: Enforces first principles thinking for architecture and problem-solving
globs: 
alwaysApply: true
---

# First Principles

Approach all architecture and problem-solving from fundamentals, not borrowed complexity.

## Architecture

- Build exactly what's needed, nothing more
- Question borrowed patterns: "Do we need this, or is there a simpler solution?"
- Challenge assumed constraints: "Is this limitation real or inherited?"
- Build from fundamentals up, not abstractions down
- Prefer the simplest solution that meets requirements
- Before adding anything: "Is this necessary to achieve the goal?"

## Problem-Solving

- Define the actual problem before attempting solutions
- Identify and fix root causes, not symptoms
- Decompose to the lowest component/denominator
- Base decisions on evidence, not convention
- Address problems at their most fundamental nature

## Anti-Patterns

- Adopting patterns wholesale without questioning fit
- Adding abstraction layers "just in case"
- Patching symptoms instead of fixing root causes
- Building for hypothetical future requirements
- Accepting constraints without verifying they're real
- Solving before fully understanding the problem

## Scope

- Apply primarily to architectural decisions, not framework internals
- Trust established frameworks (TanStack, etc.)â€”don't question their internal design
- Focus on *our* code and *our* architectural choices

## External Guidance

- Research, documentation, and articles are inputs, not directives
- Apply first-principles analysis before adopting external recommendations
- Ask: "What is the fundamental requirement?" before accepting optimization advice
- Security and correctness take precedence over performance optimizations

## Performance Optimization

Performance tools (Lighthouse, PageSpeed, WebPageTest) are diagnostic, not prescriptive.

- **Validate the problem first**: Does the flagged issue actually impact user experience?
- **Identify root cause**: "Render-blocking CSS" may mean "slow external font CDN," not "CSS is too big"
- **Question theoretical savings**: "Est savings of X ms" assumes ideal conditions; measure real impact
- **Prefer simple solutions**: Self-hosting > CDN optimization > complex deferral patterns
- **Accept reasonable blocking**: Small, fast-loading CSS is fine to be render-blocking; avoiding FOUC is valid UX

Before implementing performance "fixes":
1. What is the actual user-facing problem?
2. Is this the root cause or a symptom?
3. Is there a simpler solution?
